name: Deploy to Production

on:
  push:
    branches: [ "main" ]
    tags: [ "v*" ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Security and vulnerability scanning
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Build and test
  build-and-test:
    runs-on: ubuntu-latest
    needs: security-scan
    outputs:
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
    steps:
      - uses: actions/checkout@v4

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Log in to Container Registry
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata for backend
      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      # Extract metadata for frontend
      - name: Extract metadata for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      # Build and push backend image
      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      # Build and push frontend image
      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      # Scan built images for vulnerabilities
      - name: Scan backend image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta-backend.outputs.tags }}
          format: 'sarif'
          output: 'backend-trivy-results.sarif'

      - name: Scan frontend image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta-frontend.outputs.tags }}
          format: 'sarif'
          output: 'frontend-trivy-results.sarif'

  # Integration tests
  integration-tests:
    runs-on: ubuntu-latest
    needs: build-and-test
    services:
      postgres:
        image: bitnami/postgresql:latest
        env:
          POSTGRESQL_USERNAME: test
          POSTGRESQL_PASSWORD: test
          POSTGRESQL_DATABASE: test_vocab
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: bitnami/redis:latest
        env:
          REDIS_PASSWORD: test
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      # Set up test environment
      - name: Create test environment file
        run: |
          cat > .env.test << EOF
          APP_ENV=test
          APP_POSTGRES_HOST=localhost
          APP_POSTGRES_PORT=5432
          APP_POSTGRES_USER=test
          APP_POSTGRES_PASSWORD=test
          APP_POSTGRES_DATABASE=test_vocab
          APP_REDIS_ADDR=localhost:6379
          APP_REDIS_PASSWORD=test
          APP_JWT_SECRET=test-jwt-secret
          APP_DEEPL_APIKEY=test-api-key
          EOF

      # Run integration tests with Docker Compose
      - name: Run integration tests
        run: |
          docker-compose -f docker-compose.yml --env-file .env.test up -d --build
          # Wait for services to be ready
          sleep 30
          # Run your integration tests here
          # docker-compose exec backend go test ./tests/integration/...
          docker-compose down

  # Deploy to staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-and-test, integration-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: staging
      url: https://staging.your-domain.com
    steps:
      - uses: actions/checkout@v4

      # Deploy to staging server (example using SSH)
      - name: Deploy to staging
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /opt/english-vocab-trainer
            git pull origin main
            docker-compose -f docker-compose.prod.yml down
            docker-compose -f docker-compose.prod.yml pull
            docker-compose -f docker-compose.prod.yml up -d
            # Health check
            sleep 30
            curl -f http://localhost/health || exit 1

  # Deploy to production
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-test, integration-tests, deploy-staging]
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment:
      name: production
      url: https://your-domain.com
    steps:
      - uses: actions/checkout@v4

      # Create deployment
      - name: Create GitHub Deployment
        uses: actions/github-script@v7
        id: deployment
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'production',
              description: 'Deploy to production',
              auto_merge: false
            });
            return deployment.data.id;

      # Deploy to production server
      - name: Deploy to production
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/english-vocab-trainer
            git pull origin main

            # Backup database before deployment
            docker-compose -f docker-compose.prod.yml exec -T postgres pg_dump -U vocab_prod_user vocab_prod > backup_pre_deploy_$(date +%Y%m%d_%H%M%S).sql

            # Deploy new version
            docker-compose -f docker-compose.prod.yml down
            docker-compose -f docker-compose.prod.yml pull
            docker-compose -f docker-compose.prod.yml up -d

            # Wait for services to be ready
            sleep 60

            # Health checks
            curl -f https://your-domain.com/health || exit 1
            curl -f https://your-domain.com/api/v1/health || exit 1

      # Update deployment status
      - name: Update deployment status (success)
        uses: actions/github-script@v7
        if: success()
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ steps.deployment.outputs.result }}',
              state: 'success',
              environment_url: 'https://your-domain.com',
              description: 'Deployment successful'
            });

      - name: Update deployment status (failure)
        uses: actions/github-script@v7
        if: failure()
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ steps.deployment.outputs.result }}',
              state: 'failure',
              description: 'Deployment failed'
            });

      # Rollback on failure
      - name: Rollback on failure
        if: failure()
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /opt/english-vocab-trainer
            # Implement rollback strategy here
            # For example, restore from backup or deploy previous version
            echo "Rollback initiated due to deployment failure"

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always()
    steps:
      - name: Send notification
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ needs.deploy-production.result }}';
            const message = status === 'success'
              ? '✅ Production deployment successful!'
              : '❌ Production deployment failed!';

            // You can send notifications to Slack, Discord, email, etc.
            console.log(message);
