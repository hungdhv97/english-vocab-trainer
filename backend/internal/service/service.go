package service

import (
	"github.com/gemini-demo-apps/vocab-app/internal/models"
	"time" // Import time for CreatedAt

	
)

// WordRepository defines the interface for word data operations.
// In a real application, this would interact with a database.
type WordRepository interface {
	GetAllWords() ([]models.Word, error)
	CreateWord(word models.Word) (models.Word, error)
	UpdateWord(word models.Word) (models.Word, error)
	DeleteWord(id int64) error
}

// Service is the business logic layer.
type Service interface {
	GetAllWords() ([]models.Word, error)
	CreateWord(english, vietnamese, example string) (models.Word, error)
	UpdateWord(id int64, english, vietnamese, example string) (models.Word, error)
	DeleteWord(id int64) error
}

type service struct {
	wordRepo WordRepository
}

// NewService creates a new service instance.
func NewService(wordRepo WordRepository) Service {
	return &service{wordRepo: wordRepo}
}

// GetAllWords retrieves all words.
func (s *service) GetAllWords() ([]models.Word, error) {
	return s.wordRepo.GetAllWords()
}

// CreateWord creates a new word.
func (s *service) CreateWord(english, vietnamese, example string) (models.Word, error) {
	// In a real app, ID would be generated by DB. For now, we'll use a simple mock.
	// Or, if using UUIDs, generate here.
	newWord := models.Word{
		ID:        time.Now().UnixNano(), // Simple mock ID
		English:   english,
		Vietnamese: vietnamese,
		Example:   example,
		CreatedAt: time.Now(),
	}
	return s.wordRepo.CreateWord(newWord)
}

// UpdateWord updates an existing word.
func (s *service) UpdateWord(id int64, english, vietnamese, example string) (models.Word, error) {
	updatedWord := models.Word{
		ID:        id,
		English:   english,
		Vietnamese: vietnamese,
		Example:   example,
		// CreatedAt should ideally be fetched from existing record or not updated
	}
	return s.wordRepo.UpdateWord(updatedWord)
}

// DeleteWord deletes a word by ID.
func (s *service) DeleteWord(id int64) error {
	return s.wordRepo.DeleteWord(id)
}